use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::clock::Clock;
use solana_program::entrypoint::ProgramResult;
use solana_program::program::invoke_signed;
use solana_program::program_error::ProgramError;
use solana_program::pubkey::Pubkey;
use solana_program::account_info::{next_account_info, AccountInfo};
use solana_program::rent::Rent;
use solana_program::sysvar::Sysvar;
use solana_program::{msg, system_instruction};

use super::{
    error::MemoError,
    state::Memo,
};


#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub enum MemoInstruction {
    Create {
        content: String,
    },
    Update {
        content: String,
    },
    Delete,
}

pub fn create_memo(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    content: String,
) -> ProgramResult {
    let accounts_itr = &mut accounts.iter();

    let memo_account = next_account_info(accounts_itr)?;    // memo_account is a PDA
    let user_account = next_account_info(accounts_itr)?;    // the user who own memo
    let system_account = next_account_info(accounts_itr)?;

    // verify program ID, all of the memo account should be owned by program
    if memo_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // verify client signature
    if !user_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // verify PDA: it is generated by "fix prefix + client pubkey + program_id"
    let (pda, bump_seed) = Pubkey::find_program_address(
        &[b"memo", user_account.key.as_ref()],
        program_id
    );
    if *memo_account.key != pda {
        return Err(ProgramError::InvalidAccountData);
    }
    msg!("PDA verified: {}", pda);
    msg!("Bump seed: {}", bump_seed);

    // if memo_account is already exist
    if memo_account.lamports() > 0 {
        return Err(ProgramError::AccountAlreadyInitialized);
    }

    let memo = Memo{
        owner: *user_account.key,
        content: content,
        timestamp: Clock::get()?.unix_timestamp,
    };
    let memo_space = std::mem::size_of_val(&memo);
    let lamports = Rent::get()?.minimum_balance(memo_space);

    // if balance is not enough
    if lamports > user_account.lamports() {
        return Err(
            ProgramError::from(MemoError::InsufficientBalance)
        );
    }

    invoke_signed(
        &system_instruction::create_account(
            user_account.key,
            memo_account.key,
            lamports,
            memo_space as u64,
            program_id
        ), 
        &[
            user_account.clone(),
            memo_account.clone(),
            system_account.clone(),
        ], 
        &[&[
            b"memo",
            user_account.key.as_ref(),
            &[bump_seed]
        ]]
    )?;

    let user_lamports = user_account.lamports();
    let memo_lamports = memo_account.lamports();
    **user_account.lamports.borrow_mut() = user_lamports
        .checked_sub(memo_lamports)
        .ok_or(ProgramError::ArithmeticOverflow)?;


    memo.serialize(&mut &mut memo_account.data.borrow_mut()[..])?;

    Ok(())
}

pub fn update_memo(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    update_content: String,
) -> ProgramResult {
    let accounts_itr = &mut accounts.iter();

    let memo_account = next_account_info(accounts_itr)?;    // memo_account is a PDA
    let user_account = next_account_info(accounts_itr)?;    // the user who own memo

    // verify memo account ownership
    if program_id != memo_account.owner {
        return Err(ProgramError::InvalidAccountData);
    }

    // validate PDA
    let (pda, _) = Pubkey::find_program_address(
        &[b"memo", user_account.key.as_ref()],
        program_id
    );
    if pda != *memo_account.key {
        return Err(ProgramError::InvalidAccountData);
    }

    // verify user signature
    if !user_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    let memo = Memo::try_from_slice(&memo_account.data.borrow())?;
    // verify user ownership
    if memo.owner != *user_account.key {
        return Err(ProgramError::from(MemoError::OwnershipMismatch));
    }

    // verify lamports
    let legacy_lamport = memo_account.lamports();
    let update_memo = Memo {
        content: update_content,
        timestamp: Clock::get()?.unix_timestamp,
        ..memo
    };
    let update_memo_space = std::mem::size_of_val(&update_memo);
    let update_lamport = Rent::get()?.minimum_balance(update_memo_space);
    if update_lamport > legacy_lamport {
        let delta_lamport = update_lamport
            .checked_sub(legacy_lamport)
            .ok_or(ProgramError::ArithmeticOverflow)?;
        if delta_lamport > user_account.lamports() {
            return Err(ProgramError::from(MemoError::InsufficientBalance));
        }
        **user_account.lamports.borrow_mut() = user_account.lamports()
            .checked_sub(delta_lamport)
            .ok_or(ProgramError::ArithmeticOverflow)?;
    } else {
        let delta_lamport = legacy_lamport
            .checked_sub(update_lamport)
            .ok_or(ProgramError::ArithmeticOverflow)?;
        **user_account.lamports.borrow_mut() = user_account.lamports()
            .checked_add(delta_lamport)
            .ok_or(ProgramError::ArithmeticOverflow)?;
    }

    memo.serialize(&mut &mut memo_account.data.borrow_mut()[..])?;

    Ok(())
}

pub fn delete_memo(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    let accounts_itr = &mut accounts.iter();

    let memo_account = next_account_info(accounts_itr)?;    // memo_account is a PDA
    let user_account = next_account_info(accounts_itr)?;    // the user who own memo

    // verify program_id
    if memo_account.owner != program_id {
        return Err(ProgramError::InvalidAccountData);
    }

    // validate PDA
    let (pda, _) = Pubkey::find_program_address(
        &[b"memo", user_account.key.as_ref()],
        program_id
    );
    if pda != *memo_account.key {
        return Err(ProgramError::InvalidAccountData);
    }

    // verify user signature
    if user_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // verify user ownership
    let memo = Memo::try_from_slice(&memo_account.data.borrow())?;
    if memo.owner != *user_account.key {
        return Err(ProgramError::from(MemoError::OwnershipMismatch));
    }

    **user_account.lamports.borrow_mut() = user_account.lamports()
        .checked_add(memo_account.lamports())
        .ok_or(ProgramError::ArithmeticOverflow)?;
    **memo_account.lamports.borrow_mut() = 0;

    Ok(())
}
