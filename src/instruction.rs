use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::clock::Clock;
use solana_program::entrypoint::ProgramResult;
use solana_program::program::invoke_signed;
use solana_program::program_error::ProgramError;
use solana_program::pubkey::Pubkey;
use solana_program::account_info::{next_account_info, AccountInfo};
use solana_program::rent::Rent;
use solana_program::sysvar::Sysvar;
use solana_program::{msg, system_instruction};

use super::{
    error::MemoError,
    state::Memo,
};


#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub enum MemoInstruction {
    Create {
        content: String,
    },
    Update {
        content: String,
    },
    Delete,
}

pub fn create_memo(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    content: String,
) -> ProgramResult {
    let accounts_itr = &mut accounts.iter();

    let memo_account = next_account_info(accounts_itr)?;    // memo_account is a PDA
    let user_account = next_account_info(accounts_itr)?;    // the user who own memo
    let system_account = next_account_info(accounts_itr)?;

    // verify client signature
    if !user_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // verify PDA: it is generated by "fix prefix + client pubkey + program_id"
    let (pda, bump_seed) = Pubkey::find_program_address(
        &[b"memo", user_account.key.as_ref()],
        program_id
    );
    if *memo_account.key != pda {
        return Err(ProgramError::InvalidAccountData);
    }
    msg!("PDA verified: {}", pda);
    msg!("Bump seed: {}", bump_seed);

    // if memo_account is already exist
    if memo_account.lamports() > 0 {
        msg!("Account already exist, update memo");
        update_memo(program_id, accounts, content)?;
        return Ok(());
    }

    let memo = Memo{
        owner: *user_account.key,
        content: content,
        timestamp: Clock::get()?.unix_timestamp,
    };
    let serialized_memo = borsh::to_vec(&memo)?;
    let memo_space = serialized_memo.len();
    msg!("Required space: {} bytes", memo_space);

    // if it exceeds max memo len
    if memo_space > super::state::MAX_MEMO_SIZE {
        return Err(
            ProgramError::from(MemoError::ExceedMaxMemoLen)
        );
    }

    let lamports = Rent::get()?.minimum_balance(super::state::MAX_MEMO_SIZE);
    msg!("Required lamports: {}", lamports);

    // lamports will be automatically calculated
    invoke_signed(
        &system_instruction::create_account(
            user_account.key,
            memo_account.key,
            lamports,
            super::state::MAX_MEMO_SIZE as u64,
            program_id
        ), 
        &[
            user_account.clone(),
            memo_account.clone(),
            system_account.clone(),
        ], 
        &[&[
            b"memo",
            user_account.key.as_ref(),
            &[bump_seed]
        ]]
    )?;

    memo.serialize(&mut &mut memo_account.data.borrow_mut()[..])?;

    Ok(())
}

pub fn update_memo(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    update_content: String,
) -> ProgramResult {
    let accounts_itr = &mut accounts.iter();

    let memo_account = next_account_info(accounts_itr)?;    // memo_account is a PDA
    let user_account = next_account_info(accounts_itr)?;    // the user who own memo

    // verify memo account ownership
    if program_id != memo_account.owner {
        return Err(ProgramError::InvalidAccountData);
    }

    // validate PDA
    let (pda, _) = Pubkey::find_program_address(
        &[b"memo", user_account.key.as_ref()],
        program_id
    );
    if pda != *memo_account.key {
        return Err(ProgramError::InvalidAccountData);
    }

    // verify user signature
    if !user_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    let memo = Memo::try_from_slice(&memo_account.data.borrow())?;
    // verify user ownership
    if memo.owner != *user_account.key {
        return Err(ProgramError::from(MemoError::OwnershipMismatch));
    }

    // verify lamports
    let update_memo = Memo {
        content: update_content,
        timestamp: Clock::get()?.unix_timestamp,
        ..memo
    };
    let serialized_update_memo = borsh::to_vec(&update_memo)?;
    let update_memo_space = serialized_update_memo.len();

    // if it exceeds max len limit
    if update_memo_space > super::state::MAX_MEMO_SIZE {
        return Err(
            ProgramError::from(MemoError::ExceedMaxMemoLen)
        );
    }

    memo.serialize(&mut &mut memo_account.data.borrow_mut()[..])?;

    Ok(())
}

pub fn delete_memo(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    let accounts_itr = &mut accounts.iter();

    let memo_account = next_account_info(accounts_itr)?;    // memo_account is a PDA
    let user_account = next_account_info(accounts_itr)?;    // the user who own memo

    // verify program_id
    if memo_account.owner != program_id {
        return Err(ProgramError::InvalidAccountData);
    }

    // validate PDA
    let (pda, _) = Pubkey::find_program_address(
        &[b"memo", user_account.key.as_ref()],
        program_id
    );
    if pda != *memo_account.key {
        return Err(ProgramError::InvalidAccountData);
    }

    // verify user signature
    if user_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // verify user ownership
    let memo = Memo::try_from_slice(&memo_account.data.borrow())?;
    if memo.owner != *user_account.key {
        return Err(ProgramError::from(MemoError::OwnershipMismatch));
    }

    **user_account.lamports.borrow_mut() = user_account.lamports()
        .checked_add(memo_account.lamports())
        .ok_or(ProgramError::ArithmeticOverflow)?;
    **memo_account.lamports.borrow_mut() = 0;

    Ok(())
}
